"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// src/child-subshell/shell.ts
var import_child_process = __toESM(require("child_process"), 1);
var Shell = class {
  process;
  constructor(env_passthrough = ["PATH"]) {
    const env = { PS1: "" };
    env_passthrough.forEach((key) => {
      env[key] = process.env[key];
    });
    this.process = import_child_process.default.spawn("bash", ["--noprofile", "--norc"], {
      env,
      detached: true
    });
    this.process.stdout.setEncoding("utf8");
  }
  getStdin() {
    return this.process.stdin;
  }
  getStdout() {
    return this.process.stdout;
  }
  getStderr() {
    return this.process.stderr;
  }
  exit() {
    this.process.kill("SIGINT");
  }
};
__publicField(Shell, "logger", (...args) => process.stdout.write(args.map((a) => a.toString()).join("\n")));

// src/child-subshell/utils.ts
var LF = "\n";
var CR = "\r";
var trimFinalNewline = (input) => {
  if (input[input.length - 1] === LF) {
    input = input.slice(0, input.length - 1);
  }
  if (input[input.length - 1] === CR) {
    input = input.slice(0, input.length - 1);
  }
  return input;
};

// src/child-subshell/command.ts
var Command = class {
  shell;
  cmd;
  cwd;
  interactive;
  exec;
  runningState;
  pipe_logs;
  exit_expected;
  retCode;
  promiseResolve;
  promiseReject;
  promise;
  timer;
  stdout;
  stderr;
  constructor({
    cwd,
    shell,
    cmd,
    interactive,
    pipe_logs = false,
    exit_expected = false
  }) {
    this.shell = shell;
    this.cmd = cmd;
    this.cwd = cwd;
    this.interactive = interactive;
    this.exit_expected = exit_expected;
    this.exec = `cd "${cwd}" && 
${this.cmd};echo __END_OF_COMMAND_[$?]__
`;
    this.shell.process.on("exit", this.finish);
    this.shell.getStdout().on("data", this.handleStdoutData);
    this.shell.getStderr().on("data", this.handleStderrData);
    this.runningState = 0 /* INIT */;
    this.pipe_logs = pipe_logs;
    this.stdout = "";
    this.stderr = "";
  }
  handleStdoutData = (data) => {
    const lines = trimFinalNewline(data).split(/\r?\n/);
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const match = line.match(/__END_OF_COMMAND_\[(\d+)\]__/);
      if (match) {
        this.retCode = parseInt(match[1]);
        setImmediate(this.finish);
        return;
      } else {
        if (this.pipe_logs)
          process.stdout.write(line + "\n");
        this.stdout += line + "\n";
      }
      if (this.interactive) {
        this.interactive(line, this.handleStdinData);
      }
    }
  };
  handleStderrData = (data) => {
    if (this.pipe_logs)
      process.stderr.write(data);
    this.stderr += data;
  };
  handleStdinData = (data) => {
    this.shell.getStdin().write(`${data}
`);
  };
  run = () => {
    let promiseResolve, promiseReject;
    const promise = new Promise((resolve, reject) => {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    this.promiseResolve = promiseResolve;
    this.promiseReject = promiseReject;
    this.promise = promise;
    this.runningState = 1 /* START */;
    this.shell.getStdin().write(this.exec);
    this.timer = setTimeout(() => {
      if (this.runningState !== 2 /* END */) {
        const obj = {
          retCode: -1,
          cmd: this.cmd,
          stdout: this.stdout,
          stderr: this.stderr
        };
        this.promiseReject(obj);
      }
    }, 864e5);
    return promise.then(() => this, (e) => {
      this.log(`

SHELLAC COMMAND FAILED!
Executing: ${this.cmd} in ${this.cwd}

STDOUT:

`);
      this.log(`${this.stdout}

`);
      this.log(`STDERR:

${this.stderr}

`);
      this.shell.exit();
      throw e;
    });
  };
  finish = () => {
    this.runningState = 2 /* END */;
    clearTimeout(this.timer);
    this.shell.getStdout().removeListener("data", this.handleStdoutData);
    this.shell.getStderr().removeListener("data", this.handleStderrData);
    const obj = {
      retCode: this.retCode,
      cmd: this.cmd,
      stdout: this.stdout,
      stderr: this.stderr
    };
    const matching_exit_code = this.retCode === this.exit_expected;
    if (!matching_exit_code) {
      if (this.exit_expected === true) {
        if (this.retCode === 0) {
          this.log("NO EXIT WHEN EXPECTED");
          return this.promiseReject(obj);
        }
      } else if (this.exit_expected === false) {
        if (this.retCode !== 0) {
          this.log("EXIT WHEN NOT EXPECTED");
          return this.promiseReject(obj);
        }
      } else {
        this.log(`EXIT CODE DIDN'T MATCH`);
        return this.promiseReject(obj);
      }
    }
    return this.promiseResolve(obj);
  };
  log = Shell.logger;
};

// src/execute.ts
var import_path = __toESM(require("path"), 1);
async function IfStatement(chunk, context) {
  const { interps, last_cmd } = context;
  const [[val_type, val_id], if_clause, else_clause] = chunk;
  if (val_type !== "VALUE")
    throw new Error("If statements only accept value interpolations, not functions.");
  if (interps[val_id]) {
    return execute(if_clause, context);
  } else if (else_clause) {
    return execute(else_clause, context);
  } else {
    return last_cmd;
  }
}
async function Command2(chunk, context) {
  const { interps, cwd, shell, exit_expected } = context;
  const [str] = chunk;
  const split_cmd = str.split(/#__(?:FUNCTION|VALUE)_(\d+)__#/g);
  let cmd = "";
  let i = 0;
  for (const token of split_cmd) {
    if (i++ % 2 === 0) {
      cmd += token;
    } else {
      const interp = interps[token];
      cmd += await (typeof interp === "function" ? interp() : interp);
    }
  }
  const command = new Command({
    cwd,
    shell,
    cmd,
    pipe_logs: chunk.tag === "logged_command",
    exit_expected
  });
  return command.run();
}
async function InStatement(chunk, context) {
  const { interps } = context;
  const [arg, in_clause] = chunk;
  if (typeof arg === "string") {
    throw new Error("IN statements need an argument token.");
  }
  let new_cwd;
  if (arg.tag === "identifier") {
    const [val_type, val_id] = arg;
    if (val_type !== "VALUE")
      throw new Error("IN statements only accept value interpolations, not functions.");
    new_cwd = interps[val_id];
  } else if (arg.tag === "string_arg") {
    new_cwd = arg[0].replace(/^"|"$/g, "");
  } else {
    throw new Error(`Unknown argument token for IN statement: ${arg.tag}`);
  }
  if (!new_cwd || typeof new_cwd !== "string")
    throw new Error(`IN statements need a string value to set as the current working dir`);
  return execute(in_clause, {
    ...context,
    cwd: import_path.default.resolve(context.cwd, new_cwd)
  });
}
async function Grammar(chunk, context) {
  const { last_cmd } = context;
  let new_last_cmd = last_cmd;
  for (const sub of chunk) {
    new_last_cmd = await execute(sub, {
      ...context,
      last_cmd: new_last_cmd
    });
  }
  return new_last_cmd;
}
async function Await(chunk, context) {
  const { interps, last_cmd } = context;
  const [[val_type, val_id]] = chunk;
  if (val_type !== "FUNCTION")
    throw new Error("IN statements only accept function interpolations, not values.");
  await interps[val_id]();
  return last_cmd;
}
async function Stdout(chunk, context) {
  const { interps, last_cmd, captures } = context;
  const [out_or_err, second] = chunk;
  if (!(out_or_err === "stdout" || out_or_err === "stderr"))
    throw new Error(`Expected only 'stdout' or 'stderr', got: ${out_or_err}`);
  const capture = trimFinalNewline((last_cmd == null ? void 0 : last_cmd[out_or_err]) || "");
  const tag = second.tag;
  if (tag === "identifier") {
    const [val_type, val_id] = second;
    if (val_type !== "FUNCTION")
      throw new Error("STDOUT/STDERR statements only accept function interpolations, not values.");
    await interps[val_id](capture);
  } else if (tag === "variable_name") {
    captures[second[0]] = capture;
  } else {
    throw new Error("STDOUT/STDERR statements expect a variable name or an interpolation function.");
  }
  return last_cmd;
}
async function Exitcode(chunk, context) {
  const { interps, last_cmd } = context;
  const [exitcode, second] = chunk;
  if (exitcode !== "exitcode")
    throw new Error(`Expected only 'exitcode', got: ${exitcode}`);
  const capture = (last_cmd == null ? void 0 : last_cmd.retCode) || 0;
  const tag = second.tag;
  if (tag === "identifier") {
    const [val_type, val_id] = second;
    if (val_type !== "FUNCTION")
      throw new Error("exitcode statements only accept function interpolations, not values.");
    await interps[val_id](capture);
  } else {
    throw new Error("exitcode statements expect an interpolation function.");
  }
  return last_cmd;
}
async function ExitsStatement(chunk, context) {
  const [exit_expected, block] = chunk.length > 1 ? [Number(chunk[0][0]), chunk[1]] : [true, chunk[0]];
  return execute(block, {
    ...context,
    exit_expected
  });
}
var execute = async (chunk, context) => {
  if (Array.isArray(chunk)) {
    if (chunk.tag === "command_line" || chunk.tag === "logged_command") {
      return Command2(chunk, context);
    } else if (chunk.tag === "if_statement") {
      return IfStatement(chunk, context);
    } else if (chunk.tag === "in_statement") {
      return InStatement(chunk, context);
    } else if (chunk.tag === "grammar") {
      return await Grammar(chunk, context);
    } else if (chunk.tag === "await_statement") {
      return await Await(chunk, context);
    } else if (chunk.tag === "stdout_statement") {
      return await Stdout(chunk, context);
    } else if (chunk.tag === "exitcode_statement") {
      return await Exitcode(chunk, context);
    } else if (chunk.tag === "exits_statement") {
      return await ExitsStatement(chunk, context);
    } else {
      return context.last_cmd;
    }
  }
  return null;
};

// dist/grammar.js
var import_reghex = require("reghex");
var _ignored_expression = (0, import_reghex._pattern)(/([\s,]|#[^\n\r]+)+/);
var ignored = function _ignored(state) {
  var last_index = state.index;
  var match, node = [];
  if (match = (0, import_reghex._exec)(state, _ignored_expression)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  return (0, import_reghex.tag)(node, "ignored");
};
var _comment_line_expression = (0, import_reghex._pattern)(/\/\/\s+/);
var _comment_line_expression2 = (0, import_reghex._pattern)(/[^\n\r]*/);
var comment_line = function _comment_line(state) {
  var last_index = state.index;
  var match, node = [];
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (!(0, import_reghex._exec)(state, _comment_line_expression)) {
    state.index = last_index;
    return;
  }
  if (match = (0, import_reghex._exec)(state, _comment_line_expression2)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  return (0, import_reghex.tag)(node, "comment_line");
};
var _command_line_expression = (0, import_reghex._pattern)(/\$\s+/);
var _command_line_expression2 = (0, import_reghex._pattern)(/.*/);
var command_line = function _command_line(state) {
  var last_index = state.index;
  var match, node = [];
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (!(0, import_reghex._exec)(state, _command_line_expression)) {
    state.index = last_index;
    return;
  }
  if (match = (0, import_reghex._exec)(state, _command_line_expression2)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  return (0, import_reghex.tag)(node, "command_line");
};
var _logged_command_expression = (0, import_reghex._pattern)(/\$\$\s+/);
var _logged_command_expression2 = (0, import_reghex._pattern)(/.*/);
var logged_command = function _logged_command(state) {
  var last_index = state.index;
  var match, node = [];
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (!(0, import_reghex._exec)(state, _logged_command_expression)) {
    state.index = last_index;
    return;
  }
  if (match = (0, import_reghex._exec)(state, _logged_command_expression2)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  return (0, import_reghex.tag)(node, "logged_command");
};
var _identifier_expression = (0, import_reghex._pattern)(/VALUE|FUNCTION/);
var _identifier_expression2 = (0, import_reghex._pattern)(/\d+/);
var identifier = function _identifier(state) {
  var last_index = state.index;
  var match, node = [];
  if (!(0, import_reghex._substr)(state, "#__")) {
    state.index = last_index;
    return;
  }
  if (match = (0, import_reghex._exec)(state, _identifier_expression)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  if (!(0, import_reghex._substr)(state, "_")) {
    state.index = last_index;
    return;
  }
  if (match = (0, import_reghex._exec)(state, _identifier_expression2)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  if (!(0, import_reghex._substr)(state, "__#")) {
    state.index = last_index;
    return;
  }
  return (0, import_reghex.tag)(node, "identifier");
};
var _integer_argument_expression = (0, import_reghex._pattern)(/\d+/);
var integer_argument = function _integer_argument(state) {
  var last_index = state.index;
  var match, node = [];
  if (!(0, import_reghex._substr)(state, "(")) {
    state.index = last_index;
    return;
  }
  if (match = (0, import_reghex._exec)(state, _integer_argument_expression)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  if (!(0, import_reghex._substr)(state, ")")) {
    state.index = last_index;
    return;
  }
  return (0, import_reghex.tag)(node, "integer_argument");
};
var _variable_name_expression = (0, import_reghex._pattern)(/\S+/);
var variable_name = function _variable_name(state) {
  var last_index = state.index;
  var match, node = [];
  if (match = (0, import_reghex._exec)(state, _variable_name_expression)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  return (0, import_reghex.tag)(node, "variable_name");
};
var _string_arg_expression = (0, import_reghex._pattern)(/"[^"]*"/);
var _string_arg_expression2 = (0, import_reghex._pattern)(/\S+/);
var string_arg = function _string_arg(state) {
  var last_index = state.index;
  var match, node = [];
  block_0: {
    var index_0 = state.index;
    if (match = (0, import_reghex._exec)(state, _string_arg_expression)) {
      node.push(match);
    } else {
      state.index = index_0;
      break block_0;
    }
    return (0, import_reghex.tag)(node, "string_arg");
  }
  if (match = (0, import_reghex._exec)(state, _string_arg_expression2)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  return (0, import_reghex.tag)(node, "string_arg");
};
var _if_statement_expression = (0, import_reghex._pattern)(/if\s+/);
var if_statement = function _if_statement(state) {
  var last_index = state.index;
  var match, node = [];
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (!(0, import_reghex._exec)(state, _if_statement_expression)) {
    state.index = last_index;
    return;
  }
  if (match = identifier(state)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (!(0, import_reghex._substr)(state, "{")) {
    state.index = last_index;
    return;
  }
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (match = grammar(state)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (!(0, import_reghex._substr)(state, "}")) {
    state.index = last_index;
    return;
  }
  var index_0 = state.index;
  var length_0 = node.length;
  var index_2 = state.index;
  if (!ignored(state)) {
    state.index = index_2;
  }
  if (!(0, import_reghex._substr)(state, "else")) {
    state.index = index_0;
  }
  var index_2 = state.index;
  if (!ignored(state)) {
    state.index = index_2;
  }
  if (!(0, import_reghex._substr)(state, "{")) {
    state.index = index_0;
  }
  var index_2 = state.index;
  if (!ignored(state)) {
    state.index = index_2;
  }
  if (match = grammar(state)) {
    node.push(match);
  } else {
    state.index = index_0;
  }
  var index_2 = state.index;
  if (!ignored(state)) {
    state.index = index_2;
  }
  if (!(0, import_reghex._substr)(state, "}")) {
    state.index = index_0;
  }
  return (0, import_reghex.tag)(node, "if_statement");
};
var _in_statement_expression = (0, import_reghex._pattern)(/in\s+/);
var in_statement = function _in_statement(state) {
  var last_index = state.index;
  var match, node = [];
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (!(0, import_reghex._exec)(state, _in_statement_expression)) {
    state.index = last_index;
    return;
  }
  var length_0 = node.length;
  alternation_1: {
    block_1: {
      var index_1 = state.index;
      if (match = identifier(state)) {
        node.push(match);
      } else {
        node.length = length_0;
        state.index = index_1;
        break block_1;
      }
      break alternation_1;
    }
    if (match = string_arg(state)) {
      node.push(match);
    } else {
      node.length = length_0;
      state.index = last_index;
      return;
    }
  }
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (!(0, import_reghex._substr)(state, "{")) {
    state.index = last_index;
    return;
  }
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (match = grammar(state)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (!(0, import_reghex._substr)(state, "}")) {
    state.index = last_index;
    return;
  }
  return (0, import_reghex.tag)(node, "in_statement");
};
var _await_statement_expression = (0, import_reghex._pattern)(/await\s+/);
var await_statement = function _await_statement(state) {
  var last_index = state.index;
  var match, node = [];
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (!(0, import_reghex._exec)(state, _await_statement_expression)) {
    state.index = last_index;
    return;
  }
  if (match = identifier(state)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  return (0, import_reghex.tag)(node, "await_statement");
};
var _stdout_statement_expression = (0, import_reghex._pattern)(/std(out|err)/);
var _stdout_statement_expression2 = (0, import_reghex._pattern)(/\s+>>\s+/);
var stdout_statement = function _stdout_statement(state) {
  var last_index = state.index;
  var match, node = [];
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (match = (0, import_reghex._exec)(state, _stdout_statement_expression)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  if (!(0, import_reghex._exec)(state, _stdout_statement_expression2)) {
    state.index = last_index;
    return;
  }
  var length_0 = node.length;
  alternation_1: {
    block_1: {
      var index_1 = state.index;
      if (match = identifier(state)) {
        node.push(match);
      } else {
        node.length = length_0;
        state.index = index_1;
        break block_1;
      }
      break alternation_1;
    }
    if (match = variable_name(state)) {
      node.push(match);
    } else {
      node.length = length_0;
      state.index = last_index;
      return;
    }
  }
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  return (0, import_reghex.tag)(node, "stdout_statement");
};
var _exitcode_statement_expression = (0, import_reghex._pattern)(/\s+>>\s+/);
var exitcode_statement = function _exitcode_statement(state) {
  var last_index = state.index;
  var match, node = [];
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (match = (0, import_reghex._substr)(state, "exitcode")) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  if (!(0, import_reghex._exec)(state, _exitcode_statement_expression)) {
    state.index = last_index;
    return;
  }
  var length_0 = node.length;
  if (match = identifier(state)) {
    node.push(match);
  } else {
    node.length = length_0;
    state.index = last_index;
    return;
  }
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  return (0, import_reghex.tag)(node, "exitcode_statement");
};
var exits_statement = function _exits_statement(state) {
  var last_index = state.index;
  var match, node = [];
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (!(0, import_reghex._substr)(state, "exits")) {
    state.index = last_index;
    return;
  }
  var index_0 = state.index;
  var length_0 = node.length;
  if (match = integer_argument(state)) {
    node.push(match);
  } else {
    state.index = index_0;
  }
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (!(0, import_reghex._substr)(state, "{")) {
    state.index = last_index;
    return;
  }
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (match = grammar(state)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }
  var index_1 = state.index;
  if (!ignored(state)) {
    state.index = index_1;
  }
  if (!(0, import_reghex._substr)(state, "}")) {
    state.index = last_index;
    return;
  }
  return (0, import_reghex.tag)(node, "exits_statement");
};
var grammar = function _grammar(state) {
  var last_index = state.index;
  var match, node = [];
  loop_0:
    for (var iter_0 = 0; true; iter_0++) {
      var index_0 = state.index;
      var length_0 = node.length;
      alternation_1: {
        block_1: {
          var index_1 = state.index;
          if (!ignored(state)) {
            node.length = length_0;
            state.index = index_1;
            break block_1;
          }
          break alternation_1;
        }
        block_1: {
          var index_1 = state.index;
          if (match = comment_line(state)) {
            node.push(match);
          } else {
            node.length = length_0;
            state.index = index_1;
            break block_1;
          }
          break alternation_1;
        }
        block_1: {
          var index_1 = state.index;
          if (match = command_line(state)) {
            node.push(match);
          } else {
            node.length = length_0;
            state.index = index_1;
            break block_1;
          }
          break alternation_1;
        }
        block_1: {
          var index_1 = state.index;
          if (match = logged_command(state)) {
            node.push(match);
          } else {
            node.length = length_0;
            state.index = index_1;
            break block_1;
          }
          break alternation_1;
        }
        block_1: {
          var index_1 = state.index;
          if (match = if_statement(state)) {
            node.push(match);
          } else {
            node.length = length_0;
            state.index = index_1;
            break block_1;
          }
          break alternation_1;
        }
        block_1: {
          var index_1 = state.index;
          if (match = in_statement(state)) {
            node.push(match);
          } else {
            node.length = length_0;
            state.index = index_1;
            break block_1;
          }
          break alternation_1;
        }
        block_1: {
          var index_1 = state.index;
          if (match = await_statement(state)) {
            node.push(match);
          } else {
            node.length = length_0;
            state.index = index_1;
            break block_1;
          }
          break alternation_1;
        }
        block_1: {
          var index_1 = state.index;
          if (match = stdout_statement(state)) {
            node.push(match);
          } else {
            node.length = length_0;
            state.index = index_1;
            break block_1;
          }
          break alternation_1;
        }
        block_1: {
          var index_1 = state.index;
          if (match = exitcode_statement(state)) {
            node.push(match);
          } else {
            node.length = length_0;
            state.index = index_1;
            break block_1;
          }
          break alternation_1;
        }
        if (match = exits_statement(state)) {
          node.push(match);
        } else {
          if (iter_0) {
            state.index = index_0;
            break loop_0;
          }
          node.length = length_0;
          state.index = last_index;
          return;
        }
      }
    }
  return (0, import_reghex.tag)(node, "grammar");
};
var grammar_default = (0, import_reghex.parse)(grammar);

// src/parser.ts
var parser = (str) => grammar_default(str.trim());

// src/index.ts
var lazyCreateShell = async () => new Shell();
var _shellac = (cwd, lazyShell) => async (s, ...interps) => {
  let str = s[0];
  for (let i = 0; i < interps.length; i++) {
    const is_fn = typeof interps[i] === "function";
    const interp_placeholder = `#__${is_fn ? "FUNCTION_" : "VALUE_"}${i}__#`;
    str += interp_placeholder + s[i + 1];
  }
  if (str.length === 0)
    throw new Error("Must provide statements");
  const parsed = parser(str);
  if (!parsed || typeof parsed === "string")
    throw new Error("Parsing error!");
  const captures = {};
  const shell = await lazyShell();
  const last_cmd = await execute(parsed, {
    interps,
    last_cmd: null,
    cwd,
    captures,
    shell,
    exit_expected: false
  });
  shell.exit();
  return {
    stdout: trimFinalNewline((last_cmd == null ? void 0 : last_cmd.stdout) || ""),
    stderr: trimFinalNewline((last_cmd == null ? void 0 : last_cmd.stderr) || ""),
    ...captures
  };
};
var bgShellac = async (s, ...interps) => {
  const shell = await lazyCreateShell();
  return {
    process: shell.process,
    pid: shell.process.pid,
    promise: _shellac(process.cwd(), async () => shell)(s, ...interps),
    kill: () => shell.exit()
  };
};
var shellac = Object.assign(_shellac(process.cwd(), lazyCreateShell), {
  in: (cwd) => _shellac(cwd, lazyCreateShell),
  bg: bgShellac
});
var src_default = shellac;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
