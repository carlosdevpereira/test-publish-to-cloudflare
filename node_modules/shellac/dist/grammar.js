import { parse, _exec, _substr, _pattern, tag as _tag } from 'reghex';

var _ignored_expression = _pattern(/([\s,]|#[^\n\r]+)+/);

var ignored = function _ignored(state) {
  var last_index = state.index;
  var match,
      node = [];

  if (match = _exec(state, _ignored_expression)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  return _tag(node, 'ignored');
};

var _comment_line_expression = _pattern(/\/\/\s+/),
    _comment_line_expression2 = _pattern(/[^\n\r]*/);

var comment_line = function _comment_line(state) {
  var last_index = state.index;
  var match,
      node = [];
  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (!_exec(state, _comment_line_expression)) {
    state.index = last_index;
    return;
  }

  if (match = _exec(state, _comment_line_expression2)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  return _tag(node, 'comment_line');
};

var _command_line_expression = _pattern(/\$\s+/),
    _command_line_expression2 = _pattern(/.*/);

var command_line = function _command_line(state) {
  var last_index = state.index;
  var match,
      node = [];
  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (!_exec(state, _command_line_expression)) {
    state.index = last_index;
    return;
  }

  if (match = _exec(state, _command_line_expression2)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  return _tag(node, 'command_line');
};

var _logged_command_expression = _pattern(/\$\$\s+/),
    _logged_command_expression2 = _pattern(/.*/);

var logged_command = function _logged_command(state) {
  var last_index = state.index;
  var match,
      node = [];
  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (!_exec(state, _logged_command_expression)) {
    state.index = last_index;
    return;
  }

  if (match = _exec(state, _logged_command_expression2)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  return _tag(node, 'logged_command');
};

var _identifier_expression = _pattern(/VALUE|FUNCTION/),
    _identifier_expression2 = _pattern(/\d+/);

var identifier = function _identifier(state) {
  var last_index = state.index;
  var match,
      node = [];

  if (!_substr(state, "#__")) {
    state.index = last_index;
    return;
  }

  if (match = _exec(state, _identifier_expression)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  if (!_substr(state, "_")) {
    state.index = last_index;
    return;
  }

  if (match = _exec(state, _identifier_expression2)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  if (!_substr(state, "__#")) {
    state.index = last_index;
    return;
  }

  return _tag(node, 'identifier');
};

var _integer_argument_expression = _pattern(/\d+/);

var integer_argument = function _integer_argument(state) {
  var last_index = state.index;
  var match,
      node = [];

  if (!_substr(state, "(")) {
    state.index = last_index;
    return;
  }

  if (match = _exec(state, _integer_argument_expression)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  if (!_substr(state, ")")) {
    state.index = last_index;
    return;
  }

  return _tag(node, 'integer_argument');
};

var _variable_name_expression = _pattern(/\S+/);

var variable_name = function _variable_name(state) {
  var last_index = state.index;
  var match,
      node = [];

  if (match = _exec(state, _variable_name_expression)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  return _tag(node, 'variable_name');
};

var _string_arg_expression = _pattern(/"[^"]*"/),
    _string_arg_expression2 = _pattern(/\S+/);

var string_arg = function _string_arg(state) {
  var last_index = state.index;
  var match,
      node = [];

  block_0: {
    var index_0 = state.index;

    if (match = _exec(state, _string_arg_expression)) {
      node.push(match);
    } else {
      state.index = index_0;
      break block_0;
    }

    return _tag(node, 'string_arg');
  }

  if (match = _exec(state, _string_arg_expression2)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  return _tag(node, 'string_arg');
};

var _if_statement_expression = _pattern(/if\s+/);

var if_statement = function _if_statement(state) {
  var last_index = state.index;
  var match,
      node = [];
  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (!_exec(state, _if_statement_expression)) {
    state.index = last_index;
    return;
  }

  if (match = identifier(state)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (!_substr(state, "{")) {
    state.index = last_index;
    return;
  }

  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (match = grammar(state)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (!_substr(state, "}")) {
    state.index = last_index;
    return;
  }

  var index_0 = state.index;
  var length_0 = node.length;
  var index_2 = state.index;

  if (!ignored(state)) {
    state.index = index_2;
  }

  if (!_substr(state, "else")) {
    state.index = index_0;
  }

  var index_2 = state.index;

  if (!ignored(state)) {
    state.index = index_2;
  }

  if (!_substr(state, "{")) {
    state.index = index_0;
  }

  var index_2 = state.index;

  if (!ignored(state)) {
    state.index = index_2;
  }

  if (match = grammar(state)) {
    node.push(match);
  } else {
    state.index = index_0;
  }

  var index_2 = state.index;

  if (!ignored(state)) {
    state.index = index_2;
  }

  if (!_substr(state, "}")) {
    state.index = index_0;
  }

  return _tag(node, 'if_statement');
};

var _in_statement_expression = _pattern(/in\s+/);

var in_statement = function _in_statement(state) {
  var last_index = state.index;
  var match,
      node = [];
  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (!_exec(state, _in_statement_expression)) {
    state.index = last_index;
    return;
  }

  var length_0 = node.length;

  alternation_1: {
    block_1: {
      var index_1 = state.index;

      if (match = identifier(state)) {
        node.push(match);
      } else {
        node.length = length_0;
        state.index = index_1;
        break block_1;
      }

      break alternation_1;
    }

    if (match = string_arg(state)) {
      node.push(match);
    } else {
      node.length = length_0;
      state.index = last_index;
      return;
    }
  }

  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (!_substr(state, "{")) {
    state.index = last_index;
    return;
  }

  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (match = grammar(state)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (!_substr(state, "}")) {
    state.index = last_index;
    return;
  }

  return _tag(node, 'in_statement');
};

var _await_statement_expression = _pattern(/await\s+/);

var await_statement = function _await_statement(state) {
  var last_index = state.index;
  var match,
      node = [];
  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (!_exec(state, _await_statement_expression)) {
    state.index = last_index;
    return;
  }

  if (match = identifier(state)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  return _tag(node, 'await_statement');
};

var _stdout_statement_expression = _pattern(/std(out|err)/),
    _stdout_statement_expression2 = _pattern(/\s+>>\s+/);

var stdout_statement = function _stdout_statement(state) {
  var last_index = state.index;
  var match,
      node = [];
  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (match = _exec(state, _stdout_statement_expression)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  if (!_exec(state, _stdout_statement_expression2)) {
    state.index = last_index;
    return;
  }

  var length_0 = node.length;

  alternation_1: {
    block_1: {
      var index_1 = state.index;

      if (match = identifier(state)) {
        node.push(match);
      } else {
        node.length = length_0;
        state.index = index_1;
        break block_1;
      }

      break alternation_1;
    }

    if (match = variable_name(state)) {
      node.push(match);
    } else {
      node.length = length_0;
      state.index = last_index;
      return;
    }
  }

  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  return _tag(node, 'stdout_statement');
};

var _exitcode_statement_expression = _pattern(/\s+>>\s+/);

var exitcode_statement = function _exitcode_statement(state) {
  var last_index = state.index;
  var match,
      node = [];
  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (match = _substr(state, "exitcode")) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  if (!_exec(state, _exitcode_statement_expression)) {
    state.index = last_index;
    return;
  }

  var length_0 = node.length;

  if (match = identifier(state)) {
    node.push(match);
  } else {
    node.length = length_0;
    state.index = last_index;
    return;
  }

  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  return _tag(node, 'exitcode_statement');
};

var exits_statement = function _exits_statement(state) {
  var last_index = state.index;
  var match,
      node = [];
  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (!_substr(state, "exits")) {
    state.index = last_index;
    return;
  }

  var index_0 = state.index;
  var length_0 = node.length;

  if (match = integer_argument(state)) {
    node.push(match);
  } else {
    state.index = index_0;
  }

  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (!_substr(state, "{")) {
    state.index = last_index;
    return;
  }

  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (match = grammar(state)) {
    node.push(match);
  } else {
    state.index = last_index;
    return;
  }

  var index_1 = state.index;

  if (!ignored(state)) {
    state.index = index_1;
  }

  if (!_substr(state, "}")) {
    state.index = last_index;
    return;
  }

  return _tag(node, 'exits_statement');
};

var grammar = function _grammar(state) {
  var last_index = state.index;
  var match,
      node = [];

  loop_0: for (var iter_0 = 0; true; iter_0++) {
    var index_0 = state.index;
    var length_0 = node.length;

    alternation_1: {
      block_1: {
        var index_1 = state.index;

        if (!ignored(state)) {
          node.length = length_0;
          state.index = index_1;
          break block_1;
        }

        break alternation_1;
      }

      block_1: {
        var index_1 = state.index;

        if (match = comment_line(state)) {
          node.push(match);
        } else {
          node.length = length_0;
          state.index = index_1;
          break block_1;
        }

        break alternation_1;
      }

      block_1: {
        var index_1 = state.index;

        if (match = command_line(state)) {
          node.push(match);
        } else {
          node.length = length_0;
          state.index = index_1;
          break block_1;
        }

        break alternation_1;
      }

      block_1: {
        var index_1 = state.index;

        if (match = logged_command(state)) {
          node.push(match);
        } else {
          node.length = length_0;
          state.index = index_1;
          break block_1;
        }

        break alternation_1;
      }

      block_1: {
        var index_1 = state.index;

        if (match = if_statement(state)) {
          node.push(match);
        } else {
          node.length = length_0;
          state.index = index_1;
          break block_1;
        }

        break alternation_1;
      }

      block_1: {
        var index_1 = state.index;

        if (match = in_statement(state)) {
          node.push(match);
        } else {
          node.length = length_0;
          state.index = index_1;
          break block_1;
        }

        break alternation_1;
      }

      block_1: {
        var index_1 = state.index;

        if (match = await_statement(state)) {
          node.push(match);
        } else {
          node.length = length_0;
          state.index = index_1;
          break block_1;
        }

        break alternation_1;
      }

      block_1: {
        var index_1 = state.index;

        if (match = stdout_statement(state)) {
          node.push(match);
        } else {
          node.length = length_0;
          state.index = index_1;
          break block_1;
        }

        break alternation_1;
      }

      block_1: {
        var index_1 = state.index;

        if (match = exitcode_statement(state)) {
          node.push(match);
        } else {
          node.length = length_0;
          state.index = index_1;
          break block_1;
        }

        break alternation_1;
      }

      if (match = exits_statement(state)) {
        node.push(match);
      } else {
        if (iter_0) {
          state.index = index_0;
          break loop_0;
        }

        node.length = length_0;
        state.index = last_index;
        return;
      }
    }
  }

  return _tag(node, 'grammar');
};

export default parse(grammar);